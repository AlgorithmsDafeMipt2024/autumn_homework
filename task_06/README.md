# Реализация алгоритма LCA (Наименьший общий предок)

## Как работает алгоритм LCA (Фарах-Колтона и Бендера):

Алгоритм Фарах-Колтона и Бендера предназначен для нахождения наименьшего общего предка (`LCA`) двух узлов в дереве за константное время `O(1)` после предварительной обработки за `O(N)`, где `N` - количество узлов в дереве. Этот алгоритм использует подход, основанный на сведении задачи `LCA` к задаче `RMQ` (Range Minimum Query) - задаче поиска минимума на отрезке массива. Ключевой особенностью алгоритма является специальное свойство массива, на котором выполняется `RMQ`: разница между любыми двумя соседними элементами в массиве равна `+1` или `-1`.

### Алгоритм работает в два этапа:

#### 1. Препроцессинг (`O(N)`): На этом этапе строится вспомогательная структура данных, которая позволит быстро отвечать на запросы `LCA`. Основными шагами являются:
  1. Обход дерева DFS: Выполняется обход дерева в глубину (`DFS`) для создания массива `euler_tour` - обхода Эйлера и массива высот `h`, а также позиций вершин в массиве обхода `first_pos_in_euler_tour`.
  2. Разбиение на блоки: Массив высот euler_tour_ разбивается на блоки фиксированной длины, определяемой как `0.5 * log2(N)`.
  3. Построение разреженной таблицы (sparse table): Для эффективного поиска минимума среди блоков строится таблица `block_sparse_table`.
  4. Вычисление хешей блоков: Каждому блоку присваивается уникальный хеш, основанный на разнице высот соседних вершин внутри блока.
  5. Предвычисление `RMQ` внутри блоков: Для каждого уникального типа блока предварительно вычисляются результаты `RMQ` и сохраняются в `block_RMQ`.
  6. Предвычисление логарифмов: Заранее вычисляются значения логарифмов для всех длин от 1 до размера массива обхода `euler_tour`.

#### 2. Запрос `LCA` (`O(1)`): Когда поступает запрос на поиск `LCA` двух вершин `left` и `right`:
  1. Определяются позиции `l` и `r` этих вершин в массиве обхода euler_tour_.
  2. Определяются блоки `block_l` и `block_r`, в которых находятся позиции `l` и `r`.
  3. Если `block_l` == `block_r`, то `LCA` находится внутри блока, и используется предподсчитанное значение из `block_RMQ`.
  4. Если `block_l != block_r`, тогда ищутся минимумы для отрезка от `l` до конца блока `block_l`, для отрезка от начала блока block_r до r и для всех блоков между `block_l` и `block_r`, используя разреженную таблицу `block_sparse_table` и предвычисленные значения из `block_RMQ`.
  5. Возвращается вершина, имеющая минимальную высоту в найденных минимумах.

## Объяснение кода:
```C++
/**
 * @brief Класс для нахождения наименьшего общего предка (LCA) в дереве.
 *
 * @details Реализует алгоритм Фараха-Колтона и Бендера для нахождения LCA.
 *          Этот алгоритм сводит задачу LCA к задаче RMQ (Range Minimum Query)
 *          на специальном массиве, где разница между соседними элементами равна
 *          +1 или -1. Он обеспечивает поиск LCA за O(1) после препроцессинга за
 *          O(N), где N - количество вершин в дереве.
 *
 * @tparam vert_t: тип вершин.
 */
template <AllowedVertType vert_t>
class LCA {
 public:
  /**
   * @brief Инициализирует новый экземпляр LCA.
   *
   * @param graph: граф, для которого нужно найти LCA.
   * @param root: корень дерева.
   */
  LCA(const Graph<vert_t, size_t>& graph, vert_t root);

  /**
   * @brief Находит наименьшего общего предка двух вершин.
   *
   * @param left: первая вершина.
   * @param right: вторая вершина.
   *
   * @return `vert_t`: наименьший общий предок вершин `left` и `right`.
   */
  vert_t Ancestor(const vert_t& left, const vert_t& right) const;

  /**
   * @brief Находит наименьшего общего предка пары вершин.
   *
   * @param pair: пара вершин.
   * 
   * @return `vert_t`: наименьший общий предок вершин `pair`.
   */
  vert_t Ancestor(const std::pair<vert_t, vert_t>& pair) const;

 private:
  /**
   * @brief Обход дерева в глубину (DFS) для построения обхода Эйлера.
   *
   * @details В процессе обхода заполняет `euler_tour_`, `vert_heights_` и
   * `first_pos_in_euler_tour_`, необходимые для алгоритма.
   *
   * @param curr_vert: текущая вершина.
   * @param curr_height: текущая высота вершины.
   */
  void DFS_(const vert_t& curr_vert, ssize_t curr_height);

  /**
   * @brief Вычисляет индекс элемента с наименьшей высотой.
   *
   * @param i: индекс первого.
   * @param j: индекс второго.
   *
   * @return `ssize_t`: индекс элемента с наименьшей высотой.
   */
  ssize_t MinHeight_(ssize_t i, ssize_t j) const;
  /**
   * @brief Выполняет препроцессинг для нахождения LCA.
   *
   * @details 1.  Выполняет обход DFS для создания `euler_tour_`,
   * `vert_heights_` и `first_pos_in_euler_tour_`.
   *          2.  Разбивает `euler_tour_` на блоки размером `0.5 * log2(N)`.
   *          3.  Строит разреженную таблицу `block_sparse_table_` для RMQ на
   * блоках.
   *          4.  Вычисляет хеши блоков `block_hash_` на основе высот вершин в
   * блоках.
   *          5.  Предвычисляет `RMQ` внутри каждого уникального блока в
   * `block_RMQ_`.
   *          6.  Предвычисляет значения логарифмов в `log2_`.
   */
  void BuildLCA_();

  /**
   * @brief Находит индекс элемента с наименьшей высотой в отрезке блока.
   *
   * @details Использует предвычисленные значения из `block_RMQ_`.
   *
   * @param block_num: номер блока.
   * @param l: левая граница отрезка.
   * @param r: правая граница отрезка.
   *
   * @return `ssize_t`: индекс минимума в отрезке.
   */
  ssize_t LCAInBlock_(ssize_t block_num, ssize_t l, ssize_t r) const;

  const Graph<vert_t, size_t> graph_;

  /// @brief Корень дерева
  const vert_t root_;

  /// @brief Обход Эйлера (для вершин)
  std::vector<vert_t> euler_tour_;

  /// @brief Высота каждой вершины от корня
  std::unordered_map<vert_t, ssize_t> vert_heights_;

  /// @brief Первое вхождение вершины в обходе Эйлера
  std::unordered_map<vert_t, ssize_t> first_pos_in_euler_tour_;

  /// @brief Размер блока для RMQ (приблизительно 0.5 * log2(N)).
  ssize_t block_;

  /// @brief Разреженная таблица для поиска минимума на блоках.
  std::vector<std::vector<ssize_t>> block_sparse_table_;

  /// @brief Хэш каждого блока на основе разницы высот внутри блока.
  std::vector<ssize_t> block_hash_;

  /// @brief Предвычисленные значения для RMQ внутри каждого типа блока.
  std::vector<std::vector<std::vector<ssize_t>>> block_RMQ_;

  /// @brief Предвычисленные логарифмы для разреженной таблицы.
  std::vector<ssize_t> log2_;
};
```

Класс `LCA` реализует алгоритм Фарах-Колтона и Бендера для поиска наименьшего общего предка. Он принимает в качестве параметров граф и корень дерева.

### Пошаговое объяснение:

* #### Конструктор:
  Конструктор класса `LCA` принимает граф (`graph`) и корневую вершину (`root`). Проверяет, существует ли корневая вершина в графе. Вызывает метод `BuildLCA_` для предварительной обработки данных.
* #### Метод Ancestor:
  Проверяет, есть ли рёбра в графе. Проверяет, связаны ли вершины `left` и `right` с корнем. Находит позиции вершин в обходе Эйлера (массив `euler_tour_`) и определяет блоки, в которых они находятся. Вызывает `LCAInBlock_` для поиска `LCA` в одном блоке или же вызывает `LCAInBlock_`, `MinHeight_` и использует `block_sparse_table_` для поиска `LCA` между блоками. * Возвращает найденную вершину `LCA`.
* #### Метод DFS_:
  Выполняет обход дерева в глубину (`DFS`). Записывает высоту текущей вершины в `vert_heights_` и первое вхождение вершины в обходе Эйлера в `first_pos_in_euler_tour_`. Добавляет текущую вершину в обход Эйлера `euler_tour_`. Рекурсивно вызывает `DFS_` для каждой несвязанной соседней вершины, добавляя при этом текущую вершину в `euler_tour_` при возвращении.
* #### Метод MinHeight_:
  Сравнивает высоты двух элементов в массиве обхода `euler_tour_` по их индексам и возвращает индекс элемента с меньшей высотой.
* #### Метод BuildLCA_:
  Вызывает `DFS_` для построения обхода Эйлера и записи высот вершин. Определяет размер блока на основе размера массива обхода Эйлера. Создает разреженную таблицу `block_sparse_table_` для поиска минимума на блоках. Вычисляет хеши блоков `block_hash_` на основе разницы высот соседних вершин. Создает структуру для хранения результатов `RMQ` внутри каждого блока `block_RMQ_`. Предварительно вычисляет значения логарифмов `log2_` для использования в разреженной таблице.
* #### Метод LCAInBlock_: 
  Находит минимум на отрезке блока, используя предварительно вычисленные значения из массива `block_RMQ_`.

#### Объяснение полей класса LCA:
* `graph_`: ссылка на граф
* `root_`: корень дерева
* `euler_tour_`: массив вершин, посещенных в порядке обхода `DFS`, обход Эйлера
* `vert_heights_`: словарь, хранящий высоту каждой вершины в дереве
* `first_pos_in_euler_tour_`: словарь, хранящий первое вхождение вершины в массиве обхода
* `block_`: размер блока для алгоритма `RMQ`
* `block_sparse_table_`: разреженная таблица для минимумов на блоках
* `block_hash_`: массив хэшей для каждого блока
* `block_RMQ_`: массив, хранящий `RMQ` внутри каждого типа блока
* `log2_`: массив, хранящий предпосчитанные значения логарифмов.

## Sources:
* Алгоритм Фарака-Колтона и Бендера. — Текст : электронный // Викиконспекты ИТМО : [сайт](https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A4%D0%B0%D1%80%D0%B0%D0%BA%D0%B0-%D0%9A%D0%BE%D0%BB%D1%82%D0%BE%D0%BD%D0%B0_%D0%B8_%D0%91%D0%B5%D0%BD%D0%B4%D0%B5%D1%80%D0%B0)
* Наименьший общий предок. Нахождение за O (1) с препроцессингом O (N) (алгоритм Фарах-Колтона и Бендера). — Текст : электронный // MAXimal : [сайт](http://e-maxx.ru/algo/lca_linear)
