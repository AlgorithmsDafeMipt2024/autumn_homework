# Реализация алгоритма RMQ (Минимум на отрезке) через сведение к задаче LCA с помощью Implicit Treap

## Сведение Range Minimum Query (RMQ) к Lowest Common Ancestor (LCA)
Задача:

Дается массив `A[1...N]`. Необходимо обрабатывать запросы вида `(i, j)`, где для каждого запроса требуется найти минимальное значение в подмассиве `A` от позиции `i` до `j` включительно.

## Алгоритм

### 1. Описание
Основная идея заключается в сведении задачи RMQ к задаче LCA. Это достигается путем построения специального декартового дерева на основе входного массива `A` и последующего использования алгоритма LCA для поиска минимума в заданном диапазоне.

#### Декартово дерево по неявному ключу:

Декартово дерево, используемое в этом алгоритме, строится по неявному ключу. Это означает, что ключами узлов дерева являются индексы элементов массива `A`, а приоритетами — значения элементов массива `A` в этих индексах.

#### Соответствие RMQ и LCA:

После построения декартового дерева на массиве `A`, результат запроса RMQ для диапазона `(i, j)` эквивалентен результату запроса LCA для узлов дерева, соответствующих элементам `A[i]` и `A[j]`, то есть `RMQ(i, j) = LCA(A[i], A[j])`.

### 2. Корректность
Теорема:

`RMQ(i, j) = LCA(A[i], A[j])`

#### Доказательство:

`Пусть w = LCA(A[i], A[j])`.

Заметим, что `A[i]` и `A[j]` не могут одновременно находиться либо в левом, либо в правом поддереве узла `w`. Это связано с тем, что если бы это было так, то потомок w находился бы на большей глубине и являлся общим предком для `A[i]` и `A[j]`, что противоречит определению LCA.

Из этого следует, что узел w лежит между узлами `A[i]` и `A[j]` в структуре дерева и, следовательно, является элементом диапазона `A[i...j]`.

Из построения дерева мы знаем, что:
* Любой узел имеет значение, меньшее или равное значениям своих потомков.
* Поддерево с корнем в w содержит подмассив `A[i...j]`.

Суммируя вышесказанное, узел w является минимальным в подмассиве `A[i...j]` и, следовательно, `RMQ(i, j) = w`.

### 3. Сложность
1. Построение декартова дерева: Существует алгоритм, позволяющий построить декартово дерево за время `O(N)`.
2. Препроцессинг для LCA: Занимает `O(N)`.
3. Запрос RMQ: Отвечает на запрос за время `O(1)` после предварительной обработки за счет использования эффективного алгоритма LCA.
4. В результате получаем алгоритм RMQ, позволяющий выполнить предварительную обработку за `O(N)` и отвечать на запросы за `O(1)`.

#### Итого:

* Препроцессинг (построение дерева + подготовка LCA): `O(N)`.
* Запрос RMQ (через LCA): `O(1)`.

## Как работает Implicit Treap:

Implicit Treap (неявное декартово дерево) - это структура данных, которая сочетает в себе свойства бинарного дерева поиска и кучи. В отличие от обычного декартова дерева, ключи узлов в неявном дереве задаются неявно их индексами в массиве, а приоритеты задаются пользователем (например, значениями массива, для которого будет выполняться RMQ). Эта структура используется для построения графа на основе приоритетов массива.

### Ключевые особенности:

* Неявные ключи: Индексы элементов массива служат ключами узлов, а не их значения.
* Приоритеты: Приоритеты узлов определяются внешними значениями (например, значениями массива).
* Куча по приоритетам: Узлы расположены так, что приоритет любого узла больше приоритета всех его потомков.
* Построение графа: После построения дерева на основе приоритетов, по его структуре строится граф.
* Сведение RMQ к LCA: `ImplicitIndexTreap` преобразует массив в структуру, где задача нахождения минимума на отрезке массива сводится к задаче поиска наименьшего общего предка (LCA) в соответствующем графе.

### Процесс построения:

1. Инициализация: Создается стек для узлов дерева.
Итерация по приоритетам: Проходим по вектору приоритетов (например, массиву для RMQ) и создаем для каждой приоритетной пары (индекс, значение) новый узел.
2. Вставка узла:
    1. Сравниваем приоритет нового узла с приоритетами узлов на вершине стека, удаляя узлы с большим приоритетом до тех пор, пока приоритет нового узла не станет больше, чем у текущего верхнего узла. При удалении узлов из стека, левый и правый ребенок каждого удаленного узла будут переходить к новому узлу.
    2. Привязываем правого ребенка текущего верхнего узла к новому узлу.
    3. Добавляем новый узел в стек.
4. Создание графа: После построения дерева обходим его, строя граф на основе связей между родителями и потомками в дереве.
5. Возврат графа: Возвращается полученный граф.

## Как работает алгоритм RMQ с использованием `ImplicitIndexTreap`:

Алгоритм RMQ предназначен для поиска минимального значения на заданном диапазоне массива. В данном случае RMQ реализуется через сведение к задаче LCA с использованием `ImplicitIndexTreap`.

### Основные шаги:

1. Построение `ImplicitIndexTreap`:
    1. На основе входного массива создается неявное декартово дерево, где ключами служат индексы массива, а приоритетами – сами значения элементов массива.
    2. На основе полученного дерева создается граф, где вершины — это индексы массива, а ребра соответствуют отношениям родитель-потомок в декартовом дереве.
2. Инициализация LCA. Создается объект LCA, принимающий полученный граф и корень дерева.
3. Запрос RMQ (`Query`):
    1. На вход подаются индексы `left` и `right` (границы диапазона).
    2. Используется метод Ancestor класса LCA для нахождения наименьшего общего предка вершин `left` и `right` в построенном дереве (графе).
    3. Возвращается значение элемента массива, индекс которого является результатом вызова lca.`Ancestor(left, right)`.

### Ключевые моменты:

1. Сведение RMQ к LCA: Построение `ImplicitIndexTreap` позволяет преобразовать задачу поиска минимума на диапазоне в задачу поиска общего предка в дереве.
2. Минимальный элемент: Наименьший общий предок двух вершин в этом контексте соответствует индексу минимального элемента на заданном диапазоне.
3. Время работы: Препроцессинг занимает `O(N)`, запрос RMQ — `O(1)` за счет использования LCA.

## Объяснение кода:

### `ImplicitIndexTreap`:
```C++
/**
 * @brief Класс, представляющий неявное декартово дерево (Implicit Treap).
 * (состоит из индексов)
 *
 * @details Реализует неявное декартово дерево, где ключи являются неявными
 * (индексами), а приоритеты задаются пользователем. Дерево используется для
 * построения графа.
 *
 * @tparam vert_t: тип приоритетов.
 */
template <AllowedVertType vert_t>
class ImplicitIndexTreap {
 private:
  /// @brief Структура, представляющая узел декартова дерева.
  struct TreapNode {
    /// @brief Неявный ключ узла (индекс).
    size_t key;
    /// @brief Приоритет узла (значение в массиве).
    vert_t priority;

    /// @brief Указатель на левого потомка.
    TreapNode* left;
    /// @brief Указатель на правого потомка.
    TreapNode* right;

    /// @brief Минимальный размер поддерева, корнем которого является узел.
    size_t size;

    /**
     * @brief Конструктор узла декартова дерева.
     *
     * @param key: неявный ключ узла.
     * @param priority: приоритет узла.
     */
    TreapNode(size_t key, const vert_t& priority);

    ~TreapNode();

    /**
     * @brief Обновляет размер поддерева узла.
     *
     * @details Размер вычисляется как сумма размеров левого и правого
     * поддеревьев + 1 (текущий узел).
     */
    void UpdateSize();
  };

  // @brief Корень декартова дерева.
  TreapNode* root_;

  Graph<size_t> graph_;

 public:
  /**
   * @brief Конструктор неявного декартова дерева.
   *
   * @details Строит декартово дерево на основе переданных приоритетов,
   * используя стек. Каждый узел получает ключ-индекс, соответствующий его
   * положению в векторе. После построения дерева строится граф, где ребрами
   * являются отношения родитель-потомок.
   *
   * @throw `std::invalid_argument("ImplicitIndexTreap: priorities can not be
   * empty.")`.
   *
   * @param priorities: вектор приоритетов для узлов дерева.
   */
  ImplicitIndexTreap(const std::vector<vert_t>& priorities);

  /**
   * @brief Деструктор неявного декартова дерева.
   *
   * @details Освобождает память, выделенную для всех узлов дерева.
   */
  ~ImplicitIndexTreap();

  /**
   * @brief Возвращает граф, построенный на основе неявного декартового дерева.
   *
   * @details Состоит из индексов изначального массива.
   *
   * @return `Graph<size_t>`: граф.
   */
  const Graph<size_t> GetGraph() const;

  /**
   * @brief Возвращает ключ корня дерева.
   *
   * @return `size_t`: ключ корня.
   */
  size_t Root() const;
};
```

1. Назначение: Класс представляет неявное декартово дерево, которое строится на основе массива приоритетов. Ключами являются индексы элементов в исходном массиве, а приоритетами - сами значения.

2. Структура `TreapNode`:
    1. `key`: Индекс элемента в исходном массиве (неявный ключ).
    2. `priority`: Приоритет узла, соответствующий значению элемента в исходном массиве.
    3. `left`, `right`: Указатели на левого и правого потомков.
    4. `size`: Размер поддерева, корнем которого является этот узел. Используется для обновления информации об размере поддеревьев.

3. Конструктор:
    * Принимает вектор приоритетов (`priorities`).
    * Строит декартово дерево на основе приоритетов, используя стек. По сути происходит итерация по массиву приоритетов, добавление узлов в дерево и их связывание по принципу “стека”. На каждом шаге происходит добавление текущего узла так, чтобы дерево сохраняло свойства декартова дерева: для узла `x` приоритет `x` больше приоритета детей и потомков.
    * Создаёт граф, в котором ребрами являются отношения родитель-потомок в декартовом дереве.

4. Деструктор: Освобождает память, выделенную под узлы дерева, делая обход в глубину.

5. Методы:
    * `GetGraph()`: Возвращает граф, представляющий структуру дерева.
    * `Root()`: Возвращает ключ корня дерева.

### `RMQ`:
```C++
/**
 * @brief Класс для выполнения RMQ на массиве.
 *
 * @details Реализует RMQ, используя сведение к задаче LCA (Lowest Common
 * Ancestor). Для этого массив преобразуется в декартово дерево, а затем
 * используется алгоритм LCA для нахождения минимума на заданном диапазоне.
 *
 * @tparam vert_t: тип элементов массива. Должен соответствовать требованиям
 * `AllowedVertType`.
 */
template <AllowedVertType vert_t>
class RMQ {
 public:
  /**
   * @brief Конструктор RMQ.
   *
   * @details Создает объект RMQ на основе заданного массива. Строит неявное
   * декартово дерево из массива и инициализирует LCA для этого дерева.
   *
   * @param arr: входной массив для RMQ.
   */
  RMQ(const std::vector<vert_t>& arr);

  /**
   * @brief Выполняет запрос RMQ на заданном диапазоне массива.
   *
   * @details Возвращает значение наименьшего элемента в массиве в диапазоне
   * [left, right]. Использует ранее построенное декартово дерево и алгоритм
   * LCA.
   *
   * @param left: левая граница диапазона.
   * @param right: правая граница диапазона.
   *
   * @return `vert_t`: значение наименьшего элемента в диапазоне `[left,
   * right]`.
   */
  vert_t Query(size_t left, size_t right) const;

  /**
   * @brief Выполняет запрос RMQ на заданном диапазоне массива.
   *
   * @details Возвращает значение наименьшего элемента в массиве в диапазоне
   * `[pair.first, pair.second]`. Использует ранее построенное декартово дерево
   * и алгоритм LCA.
   *
   * @param pair: пара индексов, определяющая границы диапазона.
   *
   * @return `vert_t`: значение наименьшего элемента в диапазоне.
   */
  vert_t Query(const std::pair<size_t, size_t>& pair) const;

 private:
  /// @brief Ссылка на исходный массив.
  const std::vector<vert_t>& arr_;

  /// @brief Объект LCA для использования в запросах RMQ.
  LCA<size_t> lca_;
};
```

1. Назначение: Класс для выполнения запросов Range Minimum Query на массиве.

2. Конструктор:
    1. Принимает массив (`arr`).
    2. Строит декартово дерево на основе этого массива, используя `ImplicitIndexTreap`.
    3. Инициализирует объект `LCA` (на основе построенного дерева) для вычисления наименьшего общего предка.

3. Метод `Query()`:
    1. Принимает два индекса `left` и `right` (или пару индексов).
    2. Находит наименьшего общего предка (LCA) узлов с индексами `left` и `right` в декартовом дереве, используя объект `LCA`.
    3. Возвращает значение элемента массива, соответствующего найденному LCA. Так как структура дерева отвечает за порядок элементов в массиве (декартово дерево - куча по приоритетам), то возвращаемый элемент будет минимальным элементом на запрошенном отрезке.

4. Функция `CalculateRMQ` (внешняя): Обертка для создания объекта RMQ и вызова метода `Query()`.

## Sources:
* Сведение задачи RMQ к задаче LCA. — Текст : электронный // Викиконспекты ИТМО : [сайт](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8_RMQ_%D0%BA_%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B5_LCA)
* Декартово дерево. — Текст : электронный // Викиконспекты ИТМО : [сайт](https://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B5%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D0%B2%D0%BE_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)
