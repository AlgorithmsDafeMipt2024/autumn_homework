# Построение дерева кратчайших путей алгоритмом DAG Relaxation

Алгоритм релаксации  является стандартным алгоритмом для нахождения кратчайших путей в направленном ацикличном графе (DAG). Алгоритм работает, последовательно обновляя расстояния до каждой вершины, используя информацию о расстояниях до её предков. Он работает за линейное время (`O(|V|+|E|)`, где `V` - количество вершин, а `E` - количество ребер).

## Теория алгоритма
`𝛿(𝑠, 𝑡)` = −∞ 𝑖𝑓 𝑡ℎ𝑒𝑟𝑒 𝑖𝑠 𝑎 𝑝𝑎𝑡ℎ 𝑓𝑟𝑜𝑚 𝑠 𝑡𝑜 𝑡 𝑐𝑜𝑛𝑡𝑎𝑖𝑛𝑠
𝑎 𝑛𝑒𝑔𝑎𝑡𝑖𝑣𝑒-𝑤𝑒𝑖𝑔ℎ𝑡 𝑐𝑦𝑐𝑙𝑒

Если известны `δ(s, v)` для всех вершин `v ∈ V`, то можем 
построить дерево кратчайших путей за `O(|V|+|E|)`.

`𝛿(𝑠, 𝑡)` − кратчайший путь
`d(𝑠, 𝑡)` − оценка расстояния

Поддерживаем `d(s, v)` (изначально ∞) для каждой `v ∈ V`, 
которая всегда ограничивает сверху `δ(s, v)`, постепенно 
понижая `d`, пока не достигнем: `d(s, v) = δ(s, v)`.

Когда понижаем оценку? 

Неравенство треугольника: вес кратчайшего пути из `u` в `v` 
не может быть больше чем кратчайший путь из `u` в `v` через 
другую вершину `x`.
`𝛿(𝑢,𝑣) ≤ 𝛿(𝑢,𝑥) + 𝛿(𝑥,𝑣) 𝑓𝑜𝑟 𝑎𝑙𝑙 𝑢, 𝑣, 𝑥 ∈ 𝑉`

## Объяснение кода:

```C++
/**
 * @brief Вычисляет кратчайшие пути от заданной начальной вершины до всех других
 * вершин в направленном ациклическом графе (DAG) с помощью релаксации.
 * @tparam vert_t: тип вершины в графе
 * @tparam weight_t: тип веса в графе
 * @param graph: граф, для которого необходимо вычислить кратчайшие пути.
 * @param start_vert: начальная вершина, от которой вычисляются расстояния.
 * @throw std::invalid_argument("DAGRelaxation: there is no such start
 * vertice.")
 * @throw std::invalid_argument("DAGRelaxation: graph is not directed.");
 * @return std::unordered_map<vert_t, weight_t>: словарь, где ключ - вершина, а
 * значение - кратчайшее расстояние от start_vert до этой вершины
 * (если до вершины нет пути, то значение будет равно
 * std::numeric_limits<weight_t>::max())
 */
template <typename vert_t, typename weight_t>
std::unordered_map<vert_t, weight_t> DAGRelaxation(
    const Graph<vert_t, weight_t>& graph, vert_t start_vert)
```

1. Проверяет, что граф направленный и что начальная вершина существует.
2. Инициализирует словарь (хеш-таблицу) `dists`, где хранятся расстояния от начальной вершины до каждой. Все расстояния изначально бесконечны, кроме расстояния до самой начальной вершины, которое равно нулю.
3. Сортирует вершины графа по топологическому порядку (чтобы посетить вершину только после посещения всех ее предков).
4. Проходит по каждой вершине в этом порядке и обновляет расстояния до всех смежных вершин, если текущее расстояние до смежной вершины больше, чем сумма расстояния до текущей вершины и веса ребра между ними.

В итоге `dists` будет содержать кратчайшие расстояния от начальной вершины до всех остальных вершин в графе.

Основные моменты:
* Топологическая сортировка важна, чтобы гарантировать, что мы не будем обновлять расстояния до вершины, пока не найдем кратчайший путь к ее предку.
* Релаксация - это процесс обновления расстояний до вершин, используя информацию о расстояниях до их предков.
* Код работает только для DAG, так как для циклических графов может не сходиться.

