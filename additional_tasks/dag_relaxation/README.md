# Задача: Петя и Вася в страшном лабиринте

Петя и Вася - школьные друзья. И как все школьные друзья, они тесно общаются с охранником Валерием. 

Валерий за работой часто решает различные лабиринты, однако водить ручкой по бумаге ему уже надоело и он начал строить свои собственные лабиринты из фанеры на заднем дворе. Однажды зимним вечером он предложил ребятам пройти его последний лабиринт, где он сделал 2 входа и несколько выходов. 

Но ребята схитрили и еще днём успели узнать, как выглядит карта лабиринта. Валерий прознал об их выходке, и когда друзья уже начали его проходить, резко выключил всё освещение заднего двора. Теперь ребятам, которые всё еще боятся темноты, необходимо как можно скорее выбраться из него, не оборачиваясь назад. 

Кому первым из них удастся это сделать, если они идут по кратчайшему пути? (использовать вход школьного друга как выход - можно)

## Входные данные:

  Лабиринт в текстовом многострочном формате: 
  * `#` - стена
  * `0` - проход
  * `V` - точка входа Васи
  * `P` - точка входа Пети

  оканчивается пустой строкой

Примеры:
```
##V########
#000000000#
#0#####0#0#
#0#00000#0#
#####0###0#
P0#000#000#
#0###0#0#0#
#0#000#0#0#
#0#0###0#0#
#000#000#0#
#0###0#####

```

```
##V########
#000000000#
#0#####0#0#
#0#00000#0#
#####0###0#
P0#000#000#
#0###0#0#0#
#0#000#0#0#
#0#0###0#0#
#000#000#0#
#####0#####

```

```
###V#########
#00000000#00#
#0####0####0#
00#0#0000000#
#0#0#######0#
#0#0#0000000#
#0#0#0###0###
#0#00000#000#
#0#########0#
#0000#000000#
####0##P#####

```

```
#########V##
#000000#000#
#0####0#0#0#
#0#00#0#0#0#
00#0##0#0#0#
#0#0#00#0#0#
#0#0#0##0#0#
#0#00000000#
#0##########
#00000000000
##P#########

```

```
##V###
#00#0P
#0##0#
#0000#
######

```

## Выходные данные:

  * В единственную строке имя победителя и длина его кратчайшего маршрута.
  * В случае ничьи вывести "Draw!" и длину кратчайшего пути.
  * В случае, когда из лабиринта не удается выйти, вывести "Standoff! Valery!", тем самым обозначая, что охранник провел друзей.


# Используемый алгоритм: построение дерева кратчайших путей: DAG Relaxation (как выяснилось, для этой задачи подходит очень не очень...)

Алгоритм релаксации  является стандартным алгоритмом для нахождения кратчайших путей в направленном ацикличном графе (DAG). Алгоритм работает, последовательно обновляя расстояния до каждой вершины, используя информацию о расстояниях до её предков. Он работает за линейное время (`O(|V|+|E|)`, где `V` - количество вершин, а `E` - количество ребер).

## Теория алгоритма
`𝛿(𝑠, 𝑡)` = −∞ 𝑖𝑓 𝑡ℎ𝑒𝑟𝑒 𝑖𝑠 𝑎 𝑝𝑎𝑡ℎ 𝑓𝑟𝑜𝑚 𝑠 𝑡𝑜 𝑡 𝑐𝑜𝑛𝑡𝑎𝑖𝑛𝑠
𝑎 𝑛𝑒𝑔𝑎𝑡𝑖𝑣𝑒-𝑤𝑒𝑖𝑔ℎ𝑡 𝑐𝑦𝑐𝑙𝑒

Если известны `δ(s, v)` для всех вершин `v ∈ V`, то можем 
построить дерево кратчайших путей за `O(|V|+|E|)`.

`𝛿(𝑠, 𝑡)` − кратчайший путь
`d(𝑠, 𝑡)` − оценка расстояния

Поддерживаем `d(s, v)` (изначально ∞) для каждой `v ∈ V`, 
которая всегда ограничивает сверху `δ(s, v)`, постепенно 
понижая `d`, пока не достигнем: `d(s, v) = δ(s, v)`.

Когда понижаем оценку? 

Неравенство треугольника: вес кратчайшего пути из `u` в `v` 
не может быть больше чем кратчайший путь из `u` в `v` через 
другую вершину `x`.
`𝛿(𝑢,𝑣) ≤ 𝛿(𝑢,𝑥) + 𝛿(𝑥,𝑣) 𝑓𝑜𝑟 𝑎𝑙𝑙 𝑢, 𝑣, 𝑥 ∈ 𝑉`

## Объяснение кода:

```C++
/**
 * @brief Вычисляет кратчайшие пути от заданной начальной вершины до всех других
 * вершин в направленном ациклическом графе (DAG) с помощью релаксации.
 * @tparam vert_t: тип вершины в графе
 * @tparam weight_t: тип веса в графе
 * @param graph: граф, для которого необходимо вычислить кратчайшие пути.
 * @param start_vert: начальная вершина, от которой вычисляются расстояния.
 * @throw std::invalid_argument("DAGRelaxation: there is no such start
 * vertice.")
 * @throw std::invalid_argument("DAGRelaxation: graph is not directed.");
 * @return std::unordered_map<vert_t, weight_t>: словарь, где ключ - вершина, а
 * значение - кратчайшее расстояние от start_vert до этой вершины
 * (если до вершины нет пути, то значение будет равно
 * std::numeric_limits<weight_t>::max())
 */
template <AllowedVertType vert_t, AllowedWeightType weight_t>
std::unordered_map<vert_t, weight_t> DAGRelaxation(
    const Graph<vert_t, weight_t>& graph, vert_t start_vert)
```

1. Проверяет, что граф направленный и что начальная вершина существует.
2. Инициализирует словарь (хеш-таблицу) `dists`, где хранятся расстояния от начальной вершины до каждой. Все расстояния изначально бесконечны, кроме расстояния до самой начальной вершины, которое равно нулю.
3. Сортирует вершины графа по топологическому порядку (чтобы посетить вершину только после посещения всех ее предков).
4. Проходит по каждой вершине в этом порядке и обновляет расстояния до всех смежных вершин, если текущее расстояние до смежной вершины больше, чем сумма расстояния до текущей вершины и веса ребра между ними.

В итоге `dists` будет содержать кратчайшие расстояния от начальной вершины до всех остальных вершин в графе.

Основные моменты:
* Топологическая сортировка важна, чтобы гарантировать, что мы не будем обновлять расстояния до вершины, пока не найдем кратчайший путь к ее предку.
* Релаксация - это процесс обновления расстояний до вершин, используя информацию о расстояниях до их предков.
* Код работает только для DAG, так как для циклических графов может не сходиться.

