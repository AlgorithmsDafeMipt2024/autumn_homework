# Задача: обратимые состояния в цепочке химических экспериментов

В прогрессивной Московской химической лаборатории используют новые методы описания цепочки экспериментов: лаборанты изображают их в виде графов, вершинами которого являются состояния вещества, а эксперименты - ребрами.

Таким образом компании, разрабатывающей программное обеспечение, используя методы хемоинформатики, очень удобно использовать эксперименты этой лаборатории в своих наработках. В одном из проектов им потребовалось найти исключительно полезные состояния, обладающие свойством обратимости в цепочке. 

К обратимым экспериментам относят те, результирующее состояние вещества которых можно вернуть к исходному, через другие процессы в той же цепочке; в таком случае результирующее состояния вещества также называют обратимым.

Найдите по известной цепочке экспериментов, оформленной в виде графа, эти обратимые состояния.

## Входные данные:

* Первая строка содержит целое число `N` (`N` > 0) — количество экспериментов в графе.
* Следующие `N` строк содержат по два поля, разделенных пробелом: `A` `B`, где `A` и `B` — это строковые имена вершин (состояния веществ). Ребро идет от вершины `A` к вершине `B`. Имена вершин могут содержать любые символы, кроме пробела, переноса строки и пр.

## Выходные данные:

* Выходные данные представляют собой строку, содержащую через пробел имена всех обратимых состояний (порядок вывода обратимых состояний не важен, состояния выводятся без повторений)
* Если обратимых состояний нет, то вывод должен быть пустым.

# Используемый алгоритм: нахождение компонент сильной связности алгоритмом Тарьяна

## Как работает алгоритм Тарьяна:

Алгоритм Тарьяна - это подход к решению задачи поиска компонент сильной связности (СС) в ориентированном графе. Он работает за линейное время (`O(|V|+|E|)`, где `V` - количество вершин, а `E` - количество ребер) и использует рекурсию для эффективного обхода графа.

Алгоритм Тарьяна основывается на том, что вершина `v` является корнем СС тогда и только тогда, когда ее “низкая связь” (`low_links`) равна ее “времени входа” (`indexes`). “Низкая связь” - это минимальное “время входа” всех вершин, которые можно достичь из `v` по пути рекурсии.

Иначе говоря, вершины рассматриваются в обратном топологическом порядке, поэтому в конце рекурсивной функции для исходной вершины не будет встречено ни одной вершины из той же компоненты сильной связности, так как все вершины, достижимые из исходной, уже обработаны, и обратные связи в дереве дают второй путь из одной вершины в другую и связывают компоненты сильной связности в одну.

## Объяснение кода:

```C++
template <typename vert_t>
static void StronglyConnectedComponentsStep(
    const vert_t& v, size_t& curr_index, std::stack<vert_t>& verts_stack,
    std::unordered_map<vert_t, size_t>& indexes,
    std::unordered_map<vert_t, size_t>& low_links,
    std::unordered_map<vert_t, bool>& is_on_stack,
    std::unordered_map<vert_t, std::vector<vert_t>>& adj_list,
    std::vector<std::vector<vert_t>>& strongly_connected_components);
```

С помощью функции выше выполняется рекурсивный обход.

Для каждой вершины `v`, которая еще не была посещена, выполняется рекурсивный обход. При первом посещении вершины `v`, `indexes[v]` устанавливается равным `curr_index`, `low_links[v]` также устанавливается равным `curr_index`. `curr_index` увеличивается на 1. Вершина `v` помещается в стек `verts_stack`.

Для каждой смежной вершины `w` вершине `v` выполняется следующее:
1. Если w не была посещена (```indexes[w] == 0```): выполняется рекурсивный вызов StronglyConnectedComponentsStep для вершины `w`, `low_links[v]` обновляется минимальным значением между текущим значением и `low_links[w]`.
2. Если w уже находится в стеке (`is_on_stack[w]`):
`low_links[v]` обновляется минимальным значением между текущим значением и `low_links[w]`.

После обработки всех смежных вершин, если ```low_links[v] == indexes[v]```, это означает, что `v` является корнем СС.
В этом случае все вершины, которые находятся в стеке от v до вершины, которая была обработана ранее, также принадлежат этой СС.
Вершины удаляются из стека, пока v не будет удален. Эти удаленные вершины образуют СС, которая добавляется в список СС.

```C++
/**
 * @brief Поиск компонент сильной связности в ориентированного графа по
 * алгоритму Тарьяна
 * @tparam vert_t: тип вершин
 * @tparam weight_t: тип весов
 * @param graph: исходный граф
 * @throw std::invalid_argument("StronglyConnectedComponents: graph is not
 * directed.");
 * @return std::vector<std::vector<vert_t>>: компоненты сильной связности
 */
template <AllowedVertType vert_t, AllowedWeightType weight_t>
std::vector<std::vector<vert_t>> StronglyConnectedComponents(
    Graph<vert_t, weight_t> graph);
```

Основная функция выше вызывает ```StronglyConnectedComponentsStep(...)``` для каждой вершины графа и возвращает список компонент.