# Реализация алгоритма Джонсона

## Как работает алгоритм Джонсона:

Алгоритм Джонсона используется для нахождения кратчайших путей между всеми парами вершин в разреженном графе, который может содержать ребра с отрицательным весом, но не должен содержать отрицательных циклов. В отличие от алгоритма Флойда-Уоршелла, который работает на плотных графах, алгоритм Джонсона более эффективен на разреженных графах.

Алгоритм Джонсона является гибридным алгоритмом, сочетающим алгоритм Беллмана-Форда для обнаружения отрицательных циклов и получения потенциалов и алгоритм Дейкстры, применяемый к каждой вершине.

## Объяснение кода:
```C++
/**
 * @brief Вычисляет кратчайшие расстояния между всеми парами вершин в графе с
 * использованием алгоритма Джонсона.
 * @tparam vert_t: тип вершины в графе.
 * @tparam weight_t: тип веса в графе.
 * @param graph: граф, для которого необходимо вычислить кратчайшие пути.
 * @throw `throw std::runtime_error("Johnson: graph has negative cycle.")`.
 * @return `std::unordered_map<vert_t, std::unordered_map<vert_t, weight_t>>`:
 *  `std::unordered_map`, где:
 *      - внешний ключ - это начальная вершина.
 *      - значение - это вложенный `std::unordered_map`, где:
 *          - внутренний ключ - это конечная вершина.
 *          - значение - это кратчайшее расстояние между начальной и конечной
 *            вершинами. Если пути нет, то значение будет равно
 * `std::numeric_limits<weight_t>::max()`.
 */
template <AllowedVertType vert_t, AllowedWeightType weight_t>
inline std::unordered_map<vert_t, std::unordered_map<vert_t, weight_t>> Johnson(
    const Graph<vert_t, weight_t>& graph);
```

Функция `Johnson` принимает граф (`graph`) в качестве параметра. Она возвращает словарь, где:

внешние ключи — это начальные вершины графа.
значения — это вложенные словари, где ключами являются конечные вершины графа, а значениями - кратчайшие расстояния от начальных до конечных вершин. Если пути между вершинами нет, то значение будет равно `std::numeric_limits<weight_t>::max()`.

## Пошаговое объяснение:

1. Добавление фиктивной вершины. К исходному графу добавляется новая вершина (называемая `source_vert`), из которой проведены ребра нулевого веса ко всем остальным вершинам графа. Этот модифицированный граф используется для получения потенциалов.

2. Вычисление потенциалов с помощью алгоритма Беллмана-Форда: Алгоритм Беллмана-Форда применяется к модифицированному графу с начальной вершиной `source_vert`. Результатом работы алгоритма являются потенциалы `φ(v)` для каждой вершины `v`. Эти потенциалы используются для перевзвешивания ребер. Если алгоритм Беллмана-Форда обнаруживает отрицательный цикл, алгоритм Джонсона не может работать и генерирует исключение.

3. Перевзвешивание ребер. Вес каждого ребра `(u, v)` пересчитывается по формуле: `new_weight(u, v) = weight(u, v) + φ(u) - φ(v)`. После перевзвешивания все ребра становятся неотрицательными, что позволяет использовать алгоритм Дейкстры.

4. Применение алгоритма Дейкстры. Алгоритм Дейкстры применяется к каждой вершине графа как к начальной вершине. Это позволяет найти кратчайшие пути от каждой вершины до всех остальных в графе с перевзвешенными ребрами.

5. Корректировка расстояний. Расстояния, полученные с помощью алгоритма Дейкстры, корректируются с помощью потенциалов обратно к исходным значениям весов ребер по формуле: `original_distance(u, v) = reweighted_distance(u, v) + φ(v) - φ(u)`.

## Ограничения:

1. Алгоритм Джонсона работает корректно только для графов без отрицательных циклов.

2. Алгоритм более эффективен на разреженных графах, а для плотных лучше использовать алгоритм Флойда — Уоршелла.

### Ключевые отличия от других алгоритмов:

1. В отличие от алгоритма Беллмана-Форда, алгоритм Джонсона вычисляет кратчайшие пути между всеми парами вершин, а не от одной начальной до всех остальных.
2. В отличие от алгоритма Флойда-Уоршелла, алгоритм Джонсона эффективнее для разреженных графов, и он не вычисляет матрицу кратчайших путей, которая занимает `O(V^2)` памяти.
3. Алгоритм Джонсона объединяет Беллмана-Форда для перевзвешивания ребер и Дейкстру для получения кратчайших путей.

# Реализация алгоритма Беллмана-Форда

## Как работает алгоритм Беллмана-Форда:

Алгоритм Беллмана-Форда находит кратчайшие пути от одной начальной вершины до всех остальных вершин в графе, в том числе и в графах с ребрами отрицательного веса, при условии отсутствия отрицательных циклов. Отрицательный цикл - это цикл в графе, сумма весов ребер которого отрицательна. Если в графе есть такой цикл, то кратчайшего пути не существует, потому что пройдя по такому циклу, можно уменьшать путь до бесконечности.

Алгоритм работает путем многократной релаксации ребер. Изначально расстояние от начальной вершины до самой себя равно 0, а до всех остальных вершин — “бесконечность” (`std::numeric_limits<weight_t>::max()`). Затем, в цикле, для каждого ребра `(u, v)` алгоритм проверяет, не будет ли путь до вершины `v` короче, если пройти через вершину `u`. Этот процесс повторяется `|V| - 1` раз (где `|V|` - количество вершин в графе). После этого, алгоритм проводит дополнительную проверку на наличие отрицательных циклов.

## Объяснение кода:
```C++
/**
 * @brief Вычисляет кратчайшие пути от заданной начальной вершины до всех других
 * вершин в графе (в котором не должно быть отрицательных весовых циклов) с
 * помощью алгоритма Беллмана-Форда.
 * @tparam vert_t: тип вершины в графе.
 * @tparam weight_t: тип веса в графе.
 * @param graph: граф, для которого необходимо вычислить кратчайшие пути.
 * @param start: начальная вершина, от которой вычисляются расстояния.
 * @throw std::invalid_argument("BellmanFord: there is no such start vertice in
 * graph.").
 * @throw `throw std::runtime_error("BellmanFord: graph has negative cycle.")`.
 * @return `std::unordered_map<vert_t, weight_t>`: словарь, где ключ - вершина,
 * а значение - кратчайшее расстояние от start до этой вершины (если до вершины
 * нет пути, то значение будет равно `std::numeric_limits<weight_t>::max()`).
 */
template <AllowedVertType vert_t, AllowedWeightType weight_t>
inline std::unordered_map<vert_t, weight_t> BellmanFord(
    const Graph<vert_t, weight_t>& graph, const vert_t& start);
```

Функция `BellmanFord` принимает граф (`graph`) и начальную вершину (`start`) в качестве параметров. Она возвращает словарь, где ключи — вершины графа, а значения — кратчайшие расстояния от `start` до соответствующих вершин. Если до вершины нет пути, значение будет равно `std::numeric_limits<weight_t>::max()`.

## Пошаговое объяснение:

1. Инициализация. Создается словарь `distances` для хранения текущих минимальных расстояний от начальной вершины до всех остальных вершин. Изначально все расстояния устанавливаются в `std::numeric_limits<weight_t>::max()`, кроме начальной вершины, расстояние до которой равно 0.

2. Релаксация ребер (`|V| - 1` раз). Алгоритм перебирает все ребра графа `|V| - 1` раз. Для каждого ребра `(u, v)` с весом `weight` проверяется условие: `if (distances[u] != std::numeric_limits<weight_t>::max() && distances[u] + weight < distances[v])`. Если это условие истинно, то путь до вершины `v` можно улучшить, пройдя через вершину `u`: `distances[v] = distances[u] + weight`. Для неориентированных графов (где ребро `(u, v)` эквивалентно `(v, u)`), дополнительно проверяется и обратное ребро.

3. Проверка отрицательных циклов. После `|V| - 1` итерации релаксации, алгоритм еще раз перебирает все ребра. Если для какого-либо ребра условие `distances[u] + weight < distances[v]` все еще выполняется, это означает, что в графе есть отрицательный цикл, и алгоритм выбрасывает исключение.

4. Возврат результата: Функция возвращает словарь `distances`, содержащий кратчайшие расстояния.

## Ограничения:

1. Алгоритм Беллмана-Форда работает корректно только в графах без отрицательных циклов. В графах с отрицательными циклами кратчайшего пути не существует.

2. Алгоритм Беллмана-Форда может работать как на ориентированных так и на не ориентированных графах.

### Ключевые отличия от алгоритма Дейкстры:

1. Алгоритм Беллмана-Форда может работать с ребрами отрицательного веса.
2. Алгоритм Дейкстры быстрее (`O(E * log V)` или `O(V^2)`, тогда как у Б-Ф `O(V * E)`), но не подходит для графов с отрицательными весами.
3. Беллмана-Форда использует релаксацию всех ребер `|V| - 1` раз, что делает его медленнее чем Дейкстра.