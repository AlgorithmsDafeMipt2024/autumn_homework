# 6.4. LCA. Метод двоичного подъёма.

## Введение
Задача на нахождение наименьшего общего предка (LCA) состоит в том, чтобы для двух вершин \(u\) и \(v\) найти их наименьшего общего предка в дереве. Метод двоичного подъёма позволяет решить эту задачу за \(O(\log N)\) времени после \(O(N \log N)\) подготовки.

---

## Псевдокод

### 1. Подготовка

```text
function preprocess(tree, root):
    # g[i][j] — это предок вершины i на 2^j расстояния от неё
    for i from 0 to N-1:
        for j from 0 to log(N):
            g[i][j] = -1
    
    # Первый предок для каждой вершины (2^0 = 1 шаг вверх)
    for i from 0 to N-1:
        g[i][0] = parent[i]  # родитель вершины i
    
    # Заполнение массива g для каждого 2^j
    for j from 1 to log(N):
        for i from 0 to N-1:
            if g[i][j-1] != -1:
                g[i][j] = g[g[i][j-1]][j-1]
```

### 2. Поиск наименьшего общего предка

```text
function LCA(u, v):
    if depth[u] < depth[v]:
        swap(u, v)  # чтобы u всегда было глубже или на том же уровне
    
    # Поднимем u до уровня v
    for j from log(N)-1 downto 0:
        if depth[u] - (1 << j) >= depth[v]:
            u = g[u][j]
    
    if u == v:
        return u
    
    # Поднимем u и v, пока их предки не совпадут
    for j from log(N)-1 downto 0:
        if g[u][j] != g[v][j]:
            u = g[u][j]
            v = g[v][j]
    
    return parent[u]  # родитель u — наименьший общий предок
```

## Объяснение

- **Подготовка:** Мы заранее строим таблицу предков на различных уровнях, начиная с родителей (шаг 1) и постепенно поднимаясь вверх на 2^j шагов.
- **Поиск LCA:** Сначала выравниваем вершины u и v по глубине. Затем, начиная с самой высокой степени, поднимаемся по дереву, сокращая разницу в высоте, и находим наименьшего общего предка.

## Сложность

- **Подготовка:** \(O(N \log N)\) — для каждого из \(N\) вершин мы заполняем таблицу предков до \(O(\log N)\) уровней.
- **Поиск LCA:** \(O(\log N)\) — для двух вершин поиск общего предка займет не более \(O(\log N)\) времени.

## Применения
- В задачах на деревьях и графах для нахождения наименьших общих предков в различных структурах (например, дерево фамилий, файловые системы, и т.д.).
