# 6.3. Дерево отрезков. Изменение значения в массиве, обновление дерева отрезков. Множественные операции.

## Определение

Дерево отрезков (segment tree) — это структура данных, которая позволяет эффективно обрабатывать запросы на определение значения на отрезке (например, суммы, минимума, максимума) и изменения элементов массива.

---

## Изменение значения в массиве и обновление дерева отрезков

### Задача
Дано дерево отрезков, построенное для массива \( A \). Требуется изменить значение одного из элементов массива (\( A[i] \)) и обновить дерево отрезков так, чтобы оно снова корректно представляло новые значения.

### Алгоритм обновления
1. Найти лист дерева, соответствующий изменяемому элементу массива \( A[i] \).
2. Изменить значение в листе дерева.
3. Подняться вверх по дереву, обновляя значения всех узлов, которые зависят от измененного элемента.

### Псевдокод
1. **Обновление элемента \( A[i] \):**

```text
function update(index, newValue):
    tree[index + n] = newValue
    node = index + n
    while node > 1:
        node = parent(node)
        tree[node] = merge(tree[2 * node], tree[2 * node + 1])
```


2. **Обновление дерева:**
- Операция \( merge \) зависит от задачи:
  - Для суммы: \( merge(x, y) = x + y \).
  - Для минимума: \( merge(x, y) = min(x, y) \).
  - Для максимума: \( merge(x, y) = max(x, y) \).

### Сложность
- Изменение значения и обновление узлов: \(\mathcal{O}(\log n)\), так как дерево имеет высоту \(\log n\).

---

## Множественные операции в дереве отрезков

### Задача
Требуется обрабатывать запросы с различными операциями над отрезками, например:
- Сумма элементов (\( \text{sum} \)).
- Минимум/максимум на отрезке (\( \text{min}, \text{max} \)).
- GCD, LCM, XOR, и другие.

### Алгоритм выполнения запроса
1. Каждая операция должна быть определена через функцию объединения узлов (\( merge \)).
2. Для выполнения запроса:
- Отправить запрос к узлам дерева, соответствующим заданному отрезку.
- Результат объединяется из значений узлов, покрывающих запрос.

### Псевдокод
1. **Обработка запроса для отрезка \([L, R]\):**

```text
function query(L, R):
    result = neutralValue
    L = L + n
    R = R + n
    while L <= R:
        if L is rightChild:
            result = merge(result, tree[L])
            L = L + 1
        if R is leftChild:
            result = merge(result, tree[R])
            R = R - 1
        L = parent(L)
        R = parent(R)
    return result
```


2. **Примеры функции \( merge \):**
- Для суммы: \( merge(x, y) = x + y \).
- Для минимума: \( merge(x, y) = min(x, y) \).
- Для максимума: \( merge(x, y) = max(x, y) \).

### Сложность
- Обработка одного запроса: \(\mathcal{O}(\log n)\).

---

## Пример: Обновление и множественные запросы

### Исходные данные
Массив \( A = [1, 3, 5, 7, 9, 11] \).

### Запросы
1. Построить дерево отрезков для суммы элементов.
2. Изменить \( A[2] = 4 \) (вместо \( 5 \)).
3. Запросить сумму элементов на отрезке \([1, 4]\).

#### Построение
1. Узлы дерева:
- Листья: \( [1, 3, 5, 7, 9, 11] \).
- Узлы уровня выше: \( [4, 12, 20] \) и корень \( 36 \).

2. Изменение:
- Новый массив \( A = [1, 3, 4, 7, 9, 11] \).
- Узлы обновляются до \( [4, 11, 20] \), корень \( 35 \).

3. Запрос суммы:
- Сумма элементов \([1, 4]\) после изменений: \( 3 + 4 + 7 + 9 = 23 \).

---

## Заключение

Дерево отрезков эффективно работает с множественными операциями и позволяет:
1. Изменять значения элементов за \(\mathcal{O}(\log n)\).
2. Выполнять запросы различных типов (сумма, минимум, максимум и т.д.) за \(\mathcal{O}(\log n)\).
Эта структура данных удобна для задач, где требуется много запросов или изменений элементов массива.
