# 4.1. Остовное дерево. Построение с помощью обхода в глубину и в ширину.

## Введение

Остовное дерево (или минимальное остовное дерево) в графе — это дерево, которое включает все вершины графа, но минимизирует сумму весов рёбер. Остовное дерево является важной структурой данных и используется во множестве приложений, включая оптимизацию маршрутов, построение сетей и многое другое. Построение остовного дерева может быть выполнено с использованием различных методов, включая обход в глубину и в ширину.

## Построение остовного дерева с помощью обхода в глубину

При построении остовного дерева с помощью обхода в глубину (DFS) мы начинаем с какой-либо вершины графа и начинаем исследовать её соседей. Алгоритм аналогичен обычному поиску в глубину, но с добавлением рёбер в остовное дерево только в случае, если вершина ещё не была посещена.

### Псевдокод

```text
def dfs_spanning_tree(graph, start):
    visited = [False] * len(graph.vertices)  # Массив для отслеживания посещённых вершин
    tree_edges = []  # Список рёбер остовного дерева

    def dfs(v):
        visited[v] = True  # Отмечаем вершину как посещённую
        for neighbor in graph.adj[v]:
            if not visited[neighbor]:
                tree_edges.append((v, neighbor))  # Добавляем ребро в остовное дерево
                dfs(neighbor)  # Рекурсивно обходим соседей

    dfs(start)
    return tree_edges
```

### Объяснение

1. Алгоритм начинается с заданной вершины.
2. Мы рекурсивно обходим все соседние вершины, добавляя рёбра в остовное дерево.
3. Вершины, которые были посещены, не добавляются повторно, что гарантирует, что дерево останется связным и без циклов.
4. Алгоритм завершается, когда все вершины были посещены.

## Построение остовного дерева с помощью обхода в ширину

Алгоритм построения остовного дерева с использованием обхода в ширину (BFS) похож на DFS, но вместо рекурсии используется очередь. В отличие от DFS, BFS использует очередь для обработки вершин, что позволяет исследовать вершины слоями, начиная с ближайших к начальной вершине.

### Псевдокод

```text
def bfs_spanning_tree(graph, start):
    visited = [False] * len(graph.vertices)  # Массив для отслеживания посещённых вершин
    queue = [start]  # Очередь для обхода
    visited[start] = True
    tree_edges = []  # Список рёбер остовного дерева

    while queue:
        v = queue.pop(0)  # Извлекаем вершину из очереди
        for neighbor in graph.adj[v]:
            if not visited[neighbor]:
                visited[neighbor] = True  # Отмечаем вершину как посещённую
                tree_edges.append((v, neighbor))  # Добавляем ребро в остовное дерево
                queue.append(neighbor)  # Добавляем соседнюю вершину в очередь

    return tree_edges
```

### Объяснение

1. Мы начинаем с заданной вершины и помещаем её в очередь.
2. В цикле извлекаем вершины из очереди и добавляем их соседей в очередь, если они ещё не посещены.
3. Рёбра, которые добавляются в очередь, включаются в остовное дерево.
4. Алгоритм завершается, когда очередь пуста, то есть все вершины были посещены.

## Заключение

Остовное дерево является важной концепцией в теории графов, и его построение с помощью обходов в глубину и в ширину — это два простых метода, которые могут быть использованы для создания дерева, охватывающего все вершины графа без циклов. Оба алгоритма гарантируют, что результатом будет дерево, которое соединяет все вершины, но с разной структурой. Выбор между ними зависит от конкретных требований задачи и структуры графа.
