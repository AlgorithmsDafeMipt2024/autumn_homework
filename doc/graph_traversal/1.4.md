# 1.4. Нахождение компонент сильной связности. Алгоритм Косарайю с доказательством корректности(концепция). Алгоритм Тарьяна без доказательства корректности.

## Нахождение компонент сильной связности

В ориентированном графе компонентой сильной связности называется максимальное подмножество вершин, в котором для каждой пары вершин \( u \) и \( v \) существует путь от \( u \) к \( v \) и путь от \( v \) к \( u \).

### Алгоритм для нахождения компонент сильной связности

Для нахождения компонент сильной связности можно использовать два основных алгоритма: **алгоритм Косарайю** и **алгоритм Тарьяна**. Оба алгоритма работают за время \( O(V + E) \), где \( V \) — количество вершин, а \( E \) — количество рёбер в графе.

---

## Алгоритм Косарайю

Алгоритм Косарайю использует два обхода графа для нахождения компонент сильной связности.

### Шаги алгоритма:
1. **Первый обход (в исходном графе):** 
   - Выполняем DFS на исходном графе и сохраняем порядок завершения вершин.
   - После завершения обхода мы получаем вершины в порядке уменьшения времени выхода.

2. **Транспонирование графа:**
   - Строим транспонированный граф, где все рёбра инвертированы (если в исходном графе существует ребро \( (u, v) \), то в транспонированном графе будет ребро \( (v, u) \)).

3. **Второй обход (в транспонированном графе):**
   - Выполняем DFS по транспонированному графу, начиная с вершин в порядке, полученном в первом обходе.
   - Все вершины, которые достигаются из одной вершины во время этого обхода, принадлежат одной компоненте сильной связности.

### Псевдокод алгоритма Косарайю:
```text
Kosaraju(G):
    order = DFS(G)  # Первый обход в графе G
    G_transposed = Transpose(G)  # Транспонированный граф
    visited = [False] * V
    while order is not empty:
        u = order.pop()
        if not visited[u]:
            DFS_Transpose(G_transposed, u)  # Второй обход в транспонированном графе
```

### Доказательство корректности алгоритма Косарайю

Алгоритм Косарайю работает в два этапа: первый обход графа и второй обход по транспонированному графу. Доказательство его корректности состоит в том, что после первого обхода вершин графа, в котором сохраняются вершины в порядке уменьшения времени выхода, можно определить компоненты сильной связности в транспонированном графе, используя этот порядок.

#### Шаг 1: Первый обход в исходном графе
1. При выполнении первого обхода DFS на исходном графе мы фиксируем порядок завершения (время выхода) каждой вершины.
2. После завершения обхода, вершины будут упорядочены по времени завершения в порядке убывания. Это означает, что вершины, которые позднее завершат обход, будут иметь более высокие индексы времени выхода.

#### Шаг 2: Транспонирование графа
Транспонированный граф — это граф, в котором все рёбра инвертированы: если в исходном графе существует ребро \( (u, v) \), то в транспонированном графе будет ребро \( (v, u) \).

#### Шаг 3: Второй обход в транспонированном графе
1. После транспонирования графа, мы начинаем выполнять второй обход DFS по транспонированному графу, начиная с вершины, которая в первом обходе завершила выполнение последней.
2. В процессе второго обхода, если мы начинаем обход из вершины, которая ещё не была посещена, то все вершины, которые могут быть достигнуты из этой вершины в транспонированном графе, образуют компоненту сильной связности.
   
#### Почему это работает?
- Компоненты сильной связности в исходном графе будут полностью собраны в одну компоненту во время второго обхода. Порядок завершения вершин в первом обходе даёт нам ключевую информацию о том, какие вершины принадлежат одной компоненте.
  
- Если мы начинаем обход с вершины, которая в первом обходе завершила выполнение последней, то все вершины, которые были достигнуты во время обхода, образуют одну компоненту, поскольку они взаимно достижимы в исходном графе.

- Таким образом, в процессе второго обхода мы обрабатываем каждую компоненту сильной связности целиком, и в результате получаем все компоненты в графе.

#### Заключение
Алгоритм Косарайю гарантирует, что все компоненты сильной связности будут найдены корректно, так как второй обход в транспонированном графе позволяет точно определить компоненты сильной связности, исходя из порядка завершения вершин первого обхода. Доказательство корректности основано на свойстве обратных рёбер в транспонированном графе, которые сохраняют все взаимные зависимости между вершинами.

---

## Алгоритм Тарьяна

Алгоритм Тарьяна используется для нахождения компонент сильной связности в ориентированном графе. Он выполняет поиск в глубину (DFS) и использует стек для хранения промежуточных результатов, чтобы отслеживать компоненты сильной связности во время обхода.

### Описание алгоритма

Алгоритм Тарьяна работает за один обход графа, поддерживая для каждой вершины два значения:
1. **index** — порядковый номер времени посещения вершины.
2. **low** — минимальный порядковый номер времени посещения вершины, который можно достичь, следуя рёбрам графа, включая обратно к вершинам, уже находящимся в стеке.

Алгоритм использует стек для хранения вершин, которые ещё не были полностью обработаны. Компонента сильной связности формируется, когда для вершины выполняется условие \( low[u] = index[u] \), то есть вершина не может достичь никакой вершины с меньшим индексом, кроме себя.

### Шаги алгоритма:
1. Для каждой вершины, которая ещё не была посещена, начинается DFS. Каждой вершине присваивается уникальный индекс.
2. Во время обхода сохраняется минимальный индекс достижимых вершин в массиве **low**.
3. Когда обход завершён для вершины, если она является корнем компоненты (то есть \( low[u] = index[u] \)), вершины, находящиеся в стеке до неё, образуют компоненту сильной связности.
4. После обработки компоненты, вершины из стека извлекаются и помечаются как обработанные.

### Псевдокод алгоритма Тарьяна:

```text
Tarjan(G):
    index = 0
    stack = []
    low = [None] * V
    index_arr = [None] * V
    on_stack = [False] * V
    for each vertex u:
        if index_arr[u] is None:
            DFS_Tarjan(G, u)
```

```text
DFS_Tarjan(G, u):
    index_arr[u] = index
    low[u] = index
    index += 1
    stack.push(u)
    on_stack[u] = True
    for each vertex v in Adj[u]:
        if index_arr[v] is None:
            DFS_Tarjan(G, v)
            low[u] = min(low[u], low[v])
        else if on_stack[v]:
            low[u] = min(low[u], index_arr[v])
    if low[u] == index_arr[u]:
        component = []
        while stack.top() != u:
            v = stack.pop()
            on_stack[v] = False
            component.append(v)
        stack.pop()
        on_stack[u] = False
        component.append(u)
        output(component)
```

---

## Заключение

Алгоритм Косарайю состоит из двух обходов (по исходному и транспонированному графам), что делает его понятным и удобным для реализации. Однако он требует построения транспонированного графа, что увеличивает время работы в случае частых изменений графа.

Алгоритм Тарьяна выполняет нахождение компонент сильной связности за один проход по графу и использует стек для отслеживания вершин, что делает его более компактным и удобным для реализации в условиях, где важно минимизировать дополнительные структуры данных.

Оба алгоритма имеют сложность \( O(V + E) \) и широко применяются для анализа и разбиения графов на компоненты сильной связности.
