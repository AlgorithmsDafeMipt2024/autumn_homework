# 1.6. Компоненты вершинной двусвязности. Точки сочленения. Поиск точек сочленения.

## Компоненты вершинной двусвязности

**Компоненты вершинной двусвязности** — это такие подмножества вершин графа, что удаление любой вершины из компоненты не приводит к разбиению графа на несколько компонент связности.

Граф называется **вершинно двусвязным**, если удаление любой вершины не приводит к разбиению графа. Если граф не является вершинно двусвязным, то в нем существуют **токи сочленения**.

---

## Точки сочленения

**Точкой сочленения** (или **кризисной вершиной**) называется вершина, удаление которой увеличивает количество компонент связности в графе. Это вершины, которые имеют ключевое значение для связности графа. Удаление точки сочленения может разделить граф на несколько частей, которые не будут связаны друг с другом.

---

## Поиск точек сочленения

Для поиска точек сочленения в графе также используется модификация алгоритма поиска в глубину (DFS), аналогично алгоритму поиска мостов. Суть алгоритма заключается в отслеживании времени посещения вершин и их возможных возвратов через другие вершины.

### Алгоритм поиска точек сочленения

Как и в случае с мостами, для поиска точек сочленения поддерживаются два массива:
1. **disc[]** — время первого посещения вершины.
2. **low[]** — наименьшее время, которое может быть достигнуто через дочерние вершины (включая возвратные рёбра).

Также используется массив **parent[]**, который хранит родительскую вершину для каждой вершины в процессе обхода.

Если для вершины \( u \) выполняется условие, что \( low[v] \geq disc[u] \), то вершина \( u \) является точкой сочленения.

### Псевдокод алгоритма поиска точек сочленения:

```text
ArticulationDFS(G, u, disc, low, parent, articulation_points):
    disc[u] = low[u] = time
    time += 1
    children = 0
    for each vertex v in Adj[u]:
        if disc[v] is None:
            parent[v] = u
            children += 1
            ArticulationDFS(G, v, disc, low, parent, articulation_points)
            low[u] = min(low[u], low[v])
            if parent[u] is None and children > 1:
                articulation_points.add(u)
            if parent[u] is not None and low[v] >= disc[u]:
                articulation_points.add(u)
        else if v != parent[u]:
            low[u] = min(low[u], disc[v])
```

#### Объяснение псевдокода

1. Для каждой вершины \( u \), если она ещё не была посещена, начинается DFS.
2. Для каждой дочерней вершины \( v \) проверяется, если она не была посещена, запускаем рекурсивный DFS.
3. После обработки всех дочерних вершин, обновляем значение **low[u]**.
4. Если вершина \( u \) является точкой сочленения:
   - Если \( u \) является корнем DFS и имеет больше одной дочерней вершины, то она является точкой сочленения.
   - Если для дочерней вершины \( v \) выполняется \( low[v] \geq disc[u] \), то вершина \( u \) является точкой сочленения.

### Сложность алгоритма

Алгоритм поиска точек сочленения работает за время \( O(V + E) \), где \( V \) — количество вершин, а \( E \) — количество рёбер в графе. Алгоритм использует поиск в глубину, а каждая вершина и каждое ребро обрабатываются только один раз.

---

## Заключение

Поиск точек сочленения является важным методом анализа связности графа. Точки сочленения играют ключевую роль в устойчивости графа, так как их удаление может привести к разбиению графа на несколько компонент. Алгоритм поиска точек сочленения на основе DFS эффективен и широко применяется в задачах анализа графов, сетевых приложений и оптимизации.
