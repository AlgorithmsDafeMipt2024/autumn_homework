# 1.3. Проверка связности неориентированного графа. Поиск цикла в неориентированном и ориентированном графе. Топологическая сортировка.

## Проверка связности неориентированного графа

### Описание
Связность графа характеризует, насколько вершины графа соединены рёбрами. В неориентированном графе граф называется **связным**, если существует путь между каждой парой вершин.

### Алгоритм проверки связности
Для проверки связности неориентированного графа можно использовать алгоритм поиска в глубину (DFS) или поиска в ширину (BFS).

#### Шаги:
1. Выбираем произвольную вершину графа.
2. Применяем алгоритм DFS или BFS для обхода всех достижимых вершин, начиная с выбранной.
3. Если после завершения обхода все вершины были посещены, то граф связен. Если хотя бы одна вершина не была посещена, то граф несвязан.

### Псевдокод для проверки связности:
```text
DFS(u):
    color[u] = Gray
    for each v in Adj[u]:
        if color[v] == White:
            DFS(v)
```

---

## Поиск цикла в неориентированном и ориентированном графе

### Поиск цикла в неориентированном графе

В неориентированном графе цикл возникает, если во время обхода графа с помощью DFS мы возвращаемся в вершину, которая уже была посещена, но это не предок текущей вершины.

#### Алгоритм:
1. Выполняем DFS для каждой вершины.
2. Если в процессе обхода обнаруживается вершина, которая уже была посещена и не является предком текущей вершины, то найден цикл.

### Псевдокод для поиска цикла:
```text
DFS(u, parent):
    color[u] = Gray
    for each v in Adj[u]:
        if color[v] == White:
            DFS(v, u)
        else if v != parent:
            return True  # Цикл найден
    color[u] = Black
    return False
```

### Поиск цикла в ориентированном графе

В ориентированном графе цикл можно обнаружить, если вершина, которую мы посещаем, уже находится в стеке рекурсии. Это связано с тем, что при обходе графа с помощью DFS мы можем вернуться к вершине, которая ещё не была завершена (серая вершина).

#### Алгоритм:
1. Для каждой вершины выполняем DFS.
2. Во время обхода помечаем вершины как **серые** (в процессе обработки) и **чёрные** (обработаны).
3. Если во время обхода мы встречаем вершину, которая уже серого цвета, значит, найден цикл, так как это означает, что мы вернулись к вершине, которая ещё не была полностью обработана.
4. Если после обхода все вершины чёрные и не было найдено серых вершин, значит, цикл в графе отсутствует.

#### Псевдокод для поиска цикла:
```text
DFS(u):
    color[u] = Gray  # Помечаем вершину как серую (в процессе обработки)
    for each v in Adj[u]:
        if color[v] == Gray:  # Если вершина уже в стеке рекурсии, то цикл найден
            return True
        if color[v] == White:  # Если вершина не посещена, продолжаем обход
            if DFS(v):
                return True
    color[u] = Black  # Завершаем обработку вершины
    return False
```

---

## Топологическая сортировка

### Описание
Топологическая сортировка применяется только к **ориентированным ацикличным графам** (DAG). Это упорядочивание вершин графа так, что для каждого рёбра \( (u, v) \) вершина \( u \) предшествует вершине \( v \) в этом порядке. Топологическая сортировка используется для решения задач, где важно соблюдение зависимости между элементами, например, при планировании задач или компиляции программ.

### Алгоритм:
1. Для каждой вершины вычисляем её **входную степень** (число рёбер, направленных в неё).
2. Составляем очередь вершин с нулевой входной степенью (вершины, которые не имеют входящих рёбер).
3. Извлекаем вершину из очереди, добавляем её в топологический порядок и уменьшаем входную степень всех её соседей.
4. Повторяем процесс, пока очередь не опустеет.

Если в процессе выполнения алгоритма остаётся вершина с ненулевой входной степенью, это означает, что в графе есть цикл, и топологическая сортировка невозможна.

### Псевдокод:
```text
TopologicalSort():
    Queue = []
    for each vertex u:
        if in_degree[u] == 0:
            Queue.push(u)
    while Queue is not empty:
        u = Queue.pop()
        add u to result
        for each vertex v adjacent to u:
            in_degree[v] -= 1
            if in_degree[v] == 0:
                Queue.push(v)
```

---

### Заключение

**Топологическая сортировка** применяется только к ориентированным ацикличным графам (DAG) и позволяет упорядочить вершины графа таким образом, чтобы для каждого рёбра \( (u, v) \) вершина \( u \) предшествовала вершине \( v \). Она используется в задачах, связанных с планированием, компиляцией и расставлением приоритетов.
