# 1.5. Компоненты реберной двусвязности. Мосты. Поиск мостов.

## Компоненты реберной двусвязности

Компоненты реберной двусвязности (или рёберные компоненты) в графе — это такие подмножества рёбер, в которых любые два рёбра связаны путём, не включающим рёбер, которые являются мостами.

Граф называется **реберно двусвязным**, если удаление любого ребра не приводит к разделению графа на несколько компонент. Если граф не является реберно двусвязным, то в нем существуют **мосты**.

---

## Мосты

**Мостом** (или **девиантным ребром**) называется ребро графа, удаление которого приводит к увеличению количества компонент связности в графе.

Мосты играют ключевую роль в анализе структуры графа, так как они указывают на важные связи между различными частями графа.

---

## Поиск мостов

Для поиска мостов в графе можно использовать модификацию поиска в глубину (DFS), который позволяет эффективно находить рёбра, удаление которых разделяет граф на несколько компонент связности.

### Алгоритм поиска мостов

Алгоритм поиска мостов использует DFS и отслеживает два массива:
1. **disc[]** — время первого посещения вершины (время входа).
2. **low[]** — наименьшее время посещения вершины, которое может быть достигнуто с помощью рёбер, уже пройденных в DFS.

Если для вершины \( v \) существует сосед \( u \), который ещё не был посещён, то в ходе DFS мы углубляемся в этот соседний узел и обновляем значения **disc[]** и **low[]**. Если для вершины \( v \) мы можем найти вершину, для которой существует более раннее время посещения, то это означает, что между вершинами \( v \) и \( u \) нет мостов.

Если \( low[v] > disc[u] \), то рёберо \( (u, v) \) является мостом.

### Псевдокод алгоритма поиска мостов:

```text
BridgeDFS(G, u, disc, low, parent):
    disc[u] = low[u] = time
    time += 1
    for each vertex v in Adj[u]:
        if disc[v] is None:
            parent[v] = u
            BridgeDFS(G, v, disc, low, parent)
            low[u] = min(low[u], low[v])
            if low[v] > disc[u]:
                output (u, v)  # Ребро (u, v) — мост
        else if v != parent[u]:
            low[u] = min(low[u], disc[v])
```

#### Объяснение псевдокода

1. Для каждой вершины \( u \), если она ещё не была посещена, мы запускаем DFS.
2. При достижении вершины \( v \), если она не была посещена, выполняем рекурсивный DFS для \( v \) и обновляем значение **low[u]**.
3. Если после обхода вершины \( v \), \( low[v] > disc[u] \), то рёберо \( (u, v) \) является мостом.
4. В случае, когда вершина уже была посещена, мы обновляем значение **low[u]** для вершины \( u \).

### Сложность алгоритма

Алгоритм поиска мостов работает за время \( O(V + E) \), где \( V \) — количество вершин, а \( E \) — количество рёбер в графе. Это связано с тем, что каждая вершина и каждое ребро обрабатываются только один раз.

## Применения

Поиск мостов может быть полезен для:
- Анализа структуры графа и поиска уязвимых точек в сетях.
- Разбиения графа на компоненты, которые не теряют своей связности при удалении рёбер.
- Решения задач по анализу инфраструктуры и сетевой безопасности.

---

## Заключение

Поиск мостов — это важный инструмент для анализа графов, позволяющий выявлять рёбра, удаление которых может нарушить связность графа. Алгоритм поиска мостов на основе DFS является эффективным и широко используемым для таких задач.
