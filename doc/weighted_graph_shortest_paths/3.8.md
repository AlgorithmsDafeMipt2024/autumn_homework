# 3.8. Нахождение цикла отрицательного веса.

## Введение

Цикл отрицательного веса в графе — это цикл, сумма рёбер которого отрицательна. Это проблема, которая возникает при решении задач оптимизации с графами, где рёбра могут иметь отрицательные веса. Циклы отрицательного веса могут привести к бесконечным улучшениям в алгоритмах нахождения кратчайших путей, что делает задачу поиска кратчайших путей в графах с такими циклами неограниченной.

Для нахождения цикла отрицательного веса можно использовать модификацию алгоритма Форда-Беллмана, который способен не только находить кратчайшие пути, но и детектировать такие циклы.

## Алгоритм Форда-Беллмана для нахождения цикла отрицательного веса

Алгоритм Форда-Беллмана используется для поиска кратчайших путей в графах с отрицательными весами рёбер. Он основан на принципе релаксации рёбер и выполняет \(V - 1\) итераций, где \(V\) — количество вершин в графе. После выполнения этих итераций, если существует путь, который можно ещё улучшить, это означает, что в графе есть цикл отрицательного веса.

Чтобы найти такой цикл, мы выполняем одну дополнительную итерацию, проверяя, можно ли ещё улучшить расстояния. Если это возможно, то найден цикл отрицательного веса.

### Псевдокод:

```text
def detect_negative_cycle(graph):
    # Инициализация расстояний
    distance = [inf] * len(graph.vertices)
    parent = [None] * len(graph.vertices)
    distance[0] = 0  # Начальная вершина

    # Выполнение V-1 итераций
    for i in range(len(graph.vertices) - 1):
        for u, v, weight in graph.edges:
            if distance[u] + weight < distance[v]:
                distance[v] = distance[u] + weight
                parent[v] = u

    # Дополнительная итерация для нахождения цикла
    for u, v, weight in graph.edges:
        if distance[u] + weight < distance[v]:
            # Цикл отрицательного веса найден, восстанавливаем его
            cycle = []
            cycle.append(v)
            current = parent[v]
            while current != v:
                cycle.append(current)
                current = parent[current]
            cycle.append(v)
            cycle.reverse()
            return cycle  # Возвращаем цикл отрицательного веса
    
    return None  # Если цикла нет
```

## Пояснение псевдокода

1. **Инициализация:** Создаём массив расстояний, заполняя его бесконечностями, кроме расстояния до стартовой вершины (которое равно 0). Также создаём массив родителей, чтобы впоследствии восстановить путь.
   
2. **Основные итерации:** Для каждого ребра графа проверяется, можно ли улучшить расстояние до вершины. Если можно, то обновляется расстояние и записывается родительская вершина.

3. **Дополнительная итерация:** После \(V - 1\) итераций проводим ещё одну, чтобы проверить наличие улучшений. Если улучшение возможно, это означает наличие цикла отрицательного веса.

4. **Восстановление цикла:** Если найден цикл, мы восстанавливаем его, следуя по родителям от вершины, в которую мы зашли, и повторно находим первую вершину цикла.

## Заключение

Алгоритм Форда-Беллмана является эффективным методом для нахождения цикла отрицательного веса. Его модификация, которая выполняет дополнительную итерацию, позволяет обнаружить такие циклы и, если они существуют, восстановить сам цикл. Это важная часть многих алгоритмов для графов с отрицательными весами, таких как алгоритм поиска кратчайших путей в графах с возможными отрицательными циклами.
