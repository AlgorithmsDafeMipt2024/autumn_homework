# 3.4. Алгоритм Форда-Беллмана. Хранение в матрице: Dv) = ρ(v, t).k равно длине кратчайшего пути до вершины v) = ρ(v, t). за ровно k ребер (не более k ребер). Доказательство корректности(полное). Оценка времени работы.

## Алгоритм Форда-Беллмана

**Алгоритм Форда-Беллмана** предназначен для нахождения кратчайших путей от одной вершины в графе, который может содержать рёбра с отрицательными весами. Важно, что алгоритм Форда-Беллмана не может работать с графами, содержащими отрицательные циклы, так как такие циклы приводят к бесконечному уменьшению стоимости пути.

### Описание алгоритма:

1. **Инициализация**:
   - Для каждой вершины графа \( v \) задаём расстояние \( D(v) \) от начальной вершины до вершины \( v \).
   - Начальное значение для начальной вершины \( s \) равно 0, а для всех остальных вершин — бесконечность.

2. **Основной цикл**:
   - Алгоритм выполняет \( V - 1 \) проходов по всем рёбрам графа, где \( V \) — количество вершин в графе.
   - На каждом проходе для всех рёбер \( (u, v) \) обновляется расстояние до вершины \( v \), если найден более короткий путь через вершину \( u \):
     
     \[
     D(v) = \min(D(v), D(u) + w(u, v))
     \]
     
     где \( w(u, v) \) — вес ребра \( (u, v) \).

3. **Проверка на наличие отрицательных циклов**:
   - После выполнения \( V - 1 \) проходов, выполняется один дополнительный проход по всем рёбрам.
   - Если на этом шаге удаётся обновить какое-либо расстояние, значит, в графе существует отрицательный цикл.

4. **Завершение**:
   - Если отрицательный цикл обнаружен, алгоритм сообщает об этом.
   - В противном случае, после \( V - 1 \) проходов, все кратчайшие пути будут найдены.

---

## Хранение в матрице: \( D(v) = \rho(v, t) \).k

В алгоритме Форда-Беллмана можно хранить кратчайшие расстояния до вершины \( v \) после ровно \( k \) рёбер, где \( k \) — количество использованных рёбер. Это позволяет более гибко отслеживать динамику изменения расстояний и помогает анализировать алгоритм в различных контекстах.

### Модификация хранения:

- Пусть \( D(v, k) \) — это расстояние до вершины \( v \), которое можно достичь с использованием ровно \( k \) рёбер (не более \( k \) рёбер).
- Для каждой вершины \( v \) и каждого числа рёбер \( k \) можно создать матрицу \( D(v, k) \), которая хранит минимальное расстояние до вершины \( v \) при использовании не более \( k \) рёбер.
  
\[
D(v, k) = \min_{u \in V} \{ D(u, k-1) + w(u, v) \}
\]

где \( w(u, v) \) — вес ребра от вершины \( u \) к вершине \( v \), а \( D(u, k-1) \) — расстояние до вершины \( u \) после использования \( k-1 \) рёбер.

---

## Доказательство корректности алгоритма Форда-Беллмана

**Корректность алгоритма Форда-Беллмана** можно доказать с помощью индукции по числу рёбер в пути.

### База индукции:
На первом шаге (после 0 рёбер) расстояния до всех вершин, кроме начальной, равны бесконечности, что соответствует правильному значению для кратчайшего пути (путь длиной 0).

### Шаг индукции:
Предположим, что после \( k \) рёбер для всех вершин \( v \) верно, что \( D(v) \) — это расстояние от начальной вершины до вершины \( v \) через не более чем \( k \) рёбер. Теперь рассмотрим путь длиной \( k + 1 \). Алгоритм обновляет значение для вершины \( v \) через все возможные рёбра, и так как на предыдущем шаге корректно рассчитаны все кратчайшие пути с использованием \( k \) рёбер, на шаге \( k + 1 \) алгоритм правильно находит минимальное расстояние.

Таким образом, индуктивное доказательство подтверждает корректность алгоритма Форда-Беллмана.

---

## Оценка времени работы

Время работы алгоритма Форда-Беллмана оценивается как \( O(V \cdot E) \), где:
- \( V \) — количество вершин в графе.
- \( E \) — количество рёбер в графе.

На каждом из \( V - 1 \) шагов алгоритм проходит по всем рёбрам, проверяя возможные обновления расстояний. Таким образом, общее количество операций пропорционально \( V \cdot E \).

---

## Заключение

- **Алгоритм Форда-Беллмана** эффективно находит кратчайшие пути в графах с отрицательными весами рёбер, но не может работать с графами, содержащими отрицательные циклы.
- Время работы алгоритма составляет \( O(V \cdot E) \), что делает его применимым для графов с малым количеством рёбер.
- **Модификация с хранением в матрице** позволяет отслеживать минимальные расстояния после использования определённого количества рёбер, что может быть полезно в различных приложениях.
- **Доказательство корректности** алгоритма основано на индукции, подтверждая, что на каждом шаге алгоритм вычисляет корректные кратчайшие пути.

