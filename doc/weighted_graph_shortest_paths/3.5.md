# 3.5. Восстановление пути. Детектирование цикла отрицательного веса. Поиск самого цикла.

## Восстановление пути

После того как алгоритм Форда-Беллмана вычислит кратчайшие пути от начальной вершины до всех остальных вершин графа, может возникнуть необходимость не только найти эти кратчайшие пути, но и восстановить сами пути.

### Как восстановить путь:
1. **Использование предшествующих вершин**:
   В ходе выполнения алгоритма Форда-Беллмана мы можем хранить для каждой вершины \( v \) вершину \( p(v) \), которая предшествует вершине \( v \) на кратчайшем пути от начальной вершины.

2. **Шаги восстановления**:
   - Начинаем с конечной вершины \( t \), и поочередно переходим от неё к предшествующим вершинам \( p(t), p(p(t)), \dots \), пока не достигнем начальной вершины.
   - Полученная последовательность вершин будет представлять собой кратчайший путь от начальной вершины до конечной.

### Псевдокод восстановления пути

```text
def reconstruct_path(p, t):
    path = []
    while t != source_vertex:
        path.append(t)
        t = p[t]
    path.append(source_vertex)
    path.reverse()  # Path will be reconstructed in reverse order
    return path
```

---

## Детектирование цикла отрицательного веса

**Цикл отрицательного веса** — это цикл в графе, сумма весов рёбер которого отрицательна. Алгоритм Форда-Беллмана не может корректно работать с такими циклами, поскольку они могут привести к бесконечному уменьшению стоимости пути.

### Детектирование цикла отрицательного веса:
После того как алгоритм Форда-Беллмана выполнит \( V - 1 \) проходов, необходимо выполнить один дополнительный проход по рёбрам, чтобы проверить, можно ли ещё обновить расстояние для какой-либо вершины. Если на этом шаге удастся обновить расстояние, это будет означать, что существует отрицательный цикл.

### Псевдокод для детектирования отрицательного цикла

```text
def detect_negative_weight_cycle(graph, D, p):
    for (u, v) in graph.edges:
        if D[u] + weight(u, v) < D[v]:
            print("Negative weight cycle detected")
            return True
    return False
```

---

## Поиск самого цикла

После того как был детектирован цикл с отрицательным весом, часто требуется не только узнать о его существовании, но и найти сам цикл. Для этого можно использовать информацию о предшествующих вершинах, которая была собрана в процессе выполнения алгоритма Форда-Беллмана.

### Как найти цикл:
1. **Начало поиска**:
   Когда обнаружен цикл отрицательного веса, мы начинаем с вершины, для которой было возможно обновить расстояние. Это вершина находится в цикле.

2. **Поиск пути в цикле**:
   Используя предшествующие вершины, мы начинаем восстанавливать путь, начиная с вершины, в которой был обнаружен цикл. Когда мы возвращаемся в эту вершину, это будет означать, что мы нашли сам цикл.

### Псевдокод для поиска самого цикла

```text
def find_negative_weight_cycle(graph, D, p):
    # Find the vertex that was updated on the last iteration
    for (u, v) in graph.edges:
        if D[u] + weight(u, v) < D[v]:
            cycle = []
            vertex = v
            # Traverse the predecessor vertices until we loop back to the cycle
            for i in range(len(graph.vertices)):
                vertex = p[vertex]
                cycle.append(vertex)
                if vertex == v:
                    break
            cycle.reverse()
            return cycle
    return None
```

---

## Заключение

- **Восстановление пути** после применения алгоритма Форда-Беллмана позволяет не только вычислить кратчайшие пути, но и получить сами пути, используя информацию о предшествующих вершинах.
- **Детектирование цикла отрицательного веса** важно для корректного завершения работы алгоритма, так как такие циклы могут вызвать бесконечное уменьшение стоимости пути.
- **Поиск самого цикла** позволяет не только обнаружить, что цикл существует, но и восстановить его, что может быть полезно в различных приложениях, например, для обнаружения ошибок в графах или для решения задач оптимизации с ограничениями на веса рёбер.

