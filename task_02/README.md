# Задача:

В городе N горожане одного из районов создали локальную сеть для того, чтобы обмениваться информацией и играть вместе по сети. У них было n роутеров. Между роутерами как-то были проложены кабели. Когда-то один нерадивый коммунальщик перерезал один из проводов, и сеть стала не связной. Пользователи восстановили этот провод и решили найти узкие места сети для того, чтобы позже устранить их. Для этого они решили найти провода, при повреждении которых сеть потеряет связность, и заодно ещё найти те роутеры, при выходе из строя которых сеть также потеряет связность. Задача состоит в том, чтобы помочь пользователям сделать свою сеть надежнее.

# Реализация алгоритмов поиска мостов и точек сочленения

## Функция `FindBridges`:
```C++
/**
 * @brief Поиск мостов в графе (используя элементы алгоритма Тарьяна).
 * @tparam vert_t: тип вершин.
 * @tparam weight_t: тип весов.
 * @param graph: исходный граф.
 * @return std::vector<std::pair<vert_t, vert_t>>: мосты в графе.
 */
template <AllowedVertType vert_t, AllowedWeightType weight_t>
inline std::vector<std::pair<vert_t, vert_t>> FindBridges(
    const Graph<vert_t, weight_t>& graph);
```

### Описание:
Функция `FindBridges` находит все мосты (рёбра, удаление которых увеличивает количество компонент связности графа) в заданном неориентированном графе. Она использует модифицированный поиск в глубину (`DFS`) с элементами алгоритма Тарьяна. Алгоритм вычисляет “время входа” (индекс) каждой вершины и “низкую связь” (`low-link`) каждой вершины, что позволяет идентифицировать мосты.

### Принцип работы:
1. Инициализируются структуры данных: `indexes` (время входа), `low_links` (минимальное время входа в поддереве) и `visited`.
2. Для каждой непосещенной вершины запускается рекурсивный DFS (`FindBridgesStep`).
3. В DFS вычисляются indexes и `low_links` для текущей вершины. Если `low_links` дочерней вершины больше `indexes` текущей вершины, ребро между ними — мост.
4. Возвращает вектор пар вершин, представляющих мосты в графе.

## Функция FindCutVertices:
```C++
/**
 * @brief Поиск точек сочленения в графе (используя элементы алгоритма Тарьяна).
 * @tparam vert_t: тип вершин.
 * @tparam weight_t: тип весов.
 * @param graph: исходный граф.
 * @return std::vector<vert_t>: точки сочленения в графе.
 */
template <AllowedVertType vert_t, AllowedWeightType weight_t>
inline std::vector<vert_t> FindCutVertices(
    const Graph<vert_t, weight_t>& graph);
```

### Описание:
Функция `FindCutVertices` находит все точки сочленения (вершины, удаление которых увеличивает количество компонент связности графа) в заданном неориентированном графе. Она использует модифицированный поиск в глубину (`DFS`) с элементами алгоритма Тарьяна. Алгоритм вычисляет “время входа” и “низкую связь” каждой вершины.

### Принцип работы:
1. Инициализируются структуры данных: indexes (время входа), `low_links` (минимальное время входа в поддереве) и `visited`.
2. Для каждой непосещенной вершины запускается рекурсивный `DFS` (`FindCutVerticesStep`).
3. В DFS вычисляются `indexes` и `low_links` для текущей вершины. Если `low_links` дочерней вершины больше или равно `indexes` текущей (некорневой) вершины, то она является точкой сочленения. Если текущая вершина является корневой (первой вершиной в `DFS`) и у нее два или более дочерних узла, то она также является точкой сочленения.
4. Возвращает вектор вершин, представляющих точки сочленения.