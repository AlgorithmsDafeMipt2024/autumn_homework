# Реализация алгоритма Дейкстры

## Как работает алгоритм Дейкстры:

Алгоритм Дейкстры находит кратчайшие пути от одной начальной вершины до всех остальных вершин в графе с неотрицательными весами ребер. Он использует жадный подход, поэтапно расширяя множество вершин с известными кратчайшими путями.

Алгоритм начинается с инициализации расстояний от начальной вершины до всех остальных вершин значением бесконечности (или максимально возможным значением для используемого типа данных). Расстояние до начальной вершины устанавливается в 0. Затем, в цикле, алгоритм выбирает непосещенную вершину с минимальным расстоянием и помечает её как посещенную. После этого он обновляет расстояния до соседей выбранной вершины, если новый путь через выбранную вершину короче, чем существующее расстояние. Цикл продолжается до тех пор, пока все достижимые вершины не будут посещены.

## Объяснение кода:
```C++
/**
 * @brief Вычисляет кратчайшие пути от заданной начальной вершины до всех других
 * вершин в графе (вес в котором может быть только положительным, если есть) с
 * помощью алгоритма Дейкстры.
 * @tparam vert_t: тип вершины в графе.
 * @tparam weight_t: тип веса в графе.
 * @param graph: граф, для которого необходимо вычислить кратчайшие пути.
 * @param start: начальная вершина, от которой вычисляются расстояния.
 * @throw `throw std::logic_error("Dijkstra: graph contains negative weighted
 * edges.")`.
 * @return `std::unordered_map<vert_t, weight_t>`: словарь, где ключ - вершина,
 * а значение - кратчайшее расстояние от start до этой вершины (если до вершины
 * нет пути, то значение будет равно `std::numeric_limits<weight_t>::max()`).
 */
template <AllowedVertType vert_t, AllowedWeightType weight_t>
std::unordered_map<vert_t, weight_t> Dijkstra(
    const Graph<vert_t, weight_t>& graph, const vert_t& start);
```

Функция `Dijkstra` принимает граф (`graph`) и начальную вершину (`start`) в качестве параметров. Она возвращает словарь, где ключи — вершины графа, а значения — кратчайшие расстояния от `start` до соответствующих вершин. Если до вершины нет пути, значение будет равно `std::numeric_limits<weight_t>::max()`.

### Пошаговое объяснение:

1. Инициализация: Создаются два словаря: `distances` хранит текущие минимальные расстояния от начальной вершины до всех остальных, а `visited` отслеживает посещенные вершины. `distances` инициализируется значениями `std::numeric_limits<weight_t>::max()`, кроме начальной вершины, расстояние до которой равно 0.

2. Поиск вершины с минимальным расстоянием: В каждом цикле итерации выбирается непосещенная вершина (`min_vert`) с минимальным расстоянием из `distances`.

3. Релаксация ребер: Для всех соседей (`neighbors`) `min_vert`, алгоритм проверяет, можно ли улучшить кратчайшее расстояние до них, проходя через `min_vert`. Если вес ребра (`weight`) отрицателен, выбрасывается исключение. Обновление расстояния происходит, если `distances[min_vert] + weight < distances[neighbor]`.

4. Пометка вершины как посещенной: После обработки `min_vert`, она помечается как посещенная в `visited`.

5. Завершение: Цикл продолжается до тех пор, пока не будут обработаны все достижимые вершины (или пока `min_distance` не станет равно `std::numeric_limits<weight_t>::max()`).

6. Возврат результата: Функция возвращает словарь `distances` содержащий кратчайшие расстояния.